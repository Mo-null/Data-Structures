#include <iostream>
using namespace std;

class SinglyLinkedList {
public:
    struct Node {
        int data;
        Node* next;
        Node(int v, Node* n = nullptr) : data(v), next(n) {}
    };

    SinglyLinkedList() : head(nullptr), sz(0) {}
    ~SinglyLinkedList() { clear(); }

    // Insert at beginning
    void insert_front(int x) {
        head = new Node(x, head);
        ++sz;
    }

    // Insert at index i (0-based). If i == size, insert at end.
    void insert_at(int i, int x) {
        if (i < 0 || i > sz) {
            cout << "Invalid position\n";
            return;
        }
        if (i == 0) { insert_front(x); return; }
        Node* prev = head;
        for (int k = 0; k < i - 1; ++k) prev = prev->next;
        prev->next = new Node(x, prev->next);
        ++sz;
    }

    // Remove from beginning
    void remove_front() {
        if (!head) { cout << "List is empty\n"; return; }
        Node* tmp = head;
        head = head->next;
        delete tmp;
        --sz;
    }

    // Remove from index i (0-based)
    void remove_at(int i) {
        if (i < 0 || i >= sz || !head) {
            cout << "Invalid position or empty list\n";
            return;
        }
        if (i == 0) { remove_front(); return; }
        Node* prev = head;
        for (int k = 0; k < i - 1; ++k) prev = prev->next;
        Node* target = prev->next;
        prev->next = target->next;
        delete target;
        --sz;
    }

    // Search for element x; return pointer to node or nullptr
    Node* search(int x) const {
        Node* cur = head;
        while (cur) {
            if (cur->data == x) return cur;
            cur = cur->next;
        }
        return nullptr;
    }

    // Utility: print list
    void print() const {
        Node* cur = head;
        cout << "List: ";
        while (cur) {
            cout << cur->data;
            if (cur->next) cout << " -> ";
            cur = cur->next;
        }
        cout << "\n";
    }

    int size() const { return sz; }

private:
    Node* head;
    int sz;

    void clear() {
        while (head) {
            Node* t = head;
            head = head->next;
            delete t;
        }
        sz = 0;
    }

    // Copy control omitted for brevity (shallow copy would be dangerous)
};

int main() {
    SinglyLinkedList list;
    int choice;
    cout << "Singly Linked List Menu\n";
    cout << "1 Insert at beginning\n2 Insert at index\n3 Remove from beginning\n4 Remove at index\n5 Search element\n6 Print list\n0 Exit\n";
    while (true) {
        cout << "Enter choice: ";
        if (!(cin >> choice)) break;
        if (choice == 0) break;
        if (choice == 1) {
            int x; cout << "Value: "; cin >> x;
            list.insert_front(x);
        } else if (choice == 2) {
            int i, x; cout << "Index: "; cin >> i; cout << "Value: "; cin >> x;
            list.insert_at(i, x);
        } else if (choice == 3) {
            list.remove_front();
        } else if (choice == 4) {
            int i; cout << "Index: "; cin >> i;
            list.remove_at(i);
        } else if (choice == 5) {
            int x; cout << "Value: "; cin >> x;
            auto node = list.search(x);
            if (node) cout << "Found node at address " << node << " with value " << node->data << "\n";
            else cout << "Not found\n";
        } else if (choice == 6) {
            list.print();
            cout << "Size: " << list.size() << "\n";
        } else {
            cout << "Invalid option\n";
        }
    }
    return 0;
}























#include <iostream>
#include <stdexcept>

using namespace std;

class DoublyLinkedList {
private:
    struct Node {
        int data;
        Node* prev;
        Node* next;
        Node(int val) : data(val), prev(nullptr), next(nullptr) {}
    };

    Node* head;
    Node* tail;
    size_t sz;

public:
    DoublyLinkedList() : head(nullptr), tail(nullptr), sz(0) {}
    ~DoublyLinkedList() {
        while (head) {
            Node* tmp = head;
            head = head->next;
            delete tmp;
        }
    }

    // Insert element x at the beginning
    void insertFront(int x) {
        Node* node = new Node(x);
        if (!head) {            // empty list
            head = tail = node;
        } else {
            node->next = head;
            head->prev = node;
            head = node;
        }
        ++sz;
    }

    // Insert element x at the end
    void insertEnd(int x) {
        Node* node = new Node(x);
        if (!tail) {            // empty list
            head = tail = node;
        } else {
            tail->next = node;
            node->prev = tail;
            tail = node;
        }
        ++sz;
    }

    // Remove element from the beginning and return its value
    int removeFront() {
        if (!head) throw runtime_error("List is empty");
        Node* node = head;
        int val = node->data;
        head = head->next;
        if (head) head->prev = nullptr;
        else tail = nullptr;    // list became empty
        delete node;
        --sz;
        return val;
    }

    // Remove element from the end and return its value
    int removeEnd() {
        if (!tail) throw runtime_error("List is empty");
        Node* node = tail;
        int val = node->data;
        tail = tail->prev;
        if (tail) tail->next = nullptr;
        else head = nullptr;    // list became empty
        delete node;
        --sz;
        return val;
    }

    // Utility: print list from head to tail
    void display() const {
        Node* cur = head;
        cout << "List: ";
        while (cur) {
            cout << cur->data;
            if (cur->next) cout << " <-> ";
            cur = cur->next;
        }
        cout << '\n';
    }

    bool empty() const { return sz == 0; }
    size_t size() const { return sz; }
};

int main() {
    DoublyLinkedList dll;
    int choice, x;

    while (true) {
        cout << "\n1 Insert at beginning\n2 Insert at end\n3 Remove from beginning\n"
             << "4 Remove from end\n5 Display\n0 Exit\nChoose: ";
        if (!(cin >> choice)) break;

        try {
            switch (choice) {
                case 1:
                    cout << "Enter value: ";
                    cin >> x;
                    dll.insertFront(x);
                    cout << "Inserted " << x << " at beginning.\n";
                    break;
                case 2:
                    cout << "Enter value: ";
                    cin >> x;
                    dll.insertEnd(x);
                    cout << "Inserted " << x << " at end.\n";
                    break;
                case 3:
                    x = dll.removeFront();
                    cout << "Removed " << x << " from beginning.\n";
                    break;
                case 4:
                    x = dll.removeEnd();
                    cout << "Removed " << x << " from end.\n";
                    break;
                case 5:
                    dll.display();
                    break;
                case 0:
                    cout << "Exiting.\n";
                    return 0;
                default:
                    cout << "Invalid choice.\n";
            }
        } catch (const exception& e) {
            cout << "Error: " << e.what() << '\n';
        }
    }

    return 0;
}


























#include <iostream>

using namespace std;

class CircularLinkedList {
public:
    struct Node {            // kept public so callers can hold the pointer if needed
        int data;
        Node* next;
        Node(int v) : data(v), next(nullptr) {}
    };

private:
    Node* tail;   // tail->next is head
    size_t sz;

public:
    CircularLinkedList() : tail(nullptr), sz(0) {}

    // Insert x at end (O(1)), preserving circularity
    void insert(int x) {
        Node* node = new Node(x);
        if (!tail) {
            node->next = node;
            tail = node;
        } else {
            node->next = tail->next; // new->next = old head
            tail->next = node;
            tail = node;             // tail now points to new node
        }
        ++sz;
    }

    // Remove first occurrence of x; returns true if removed (O(n))
    bool remove(int x) {
        if (!tail) return false; // empty

        Node* prev = tail;
        Node* cur = tail->next; // head
        for (size_t i = 0; i < sz; ++i) {
            if (cur->data == x) {
                if (cur == prev) { // only one node
                    delete cur;
                    tail = nullptr;
                } else {
                    prev->next = cur->next;
                    if (cur == tail) tail = prev; // removed tail
                    delete cur;
                }
                --sz;
                return true;
            }
            prev = cur;
            cur = cur->next;
        }
        return false; // not found
    }

    // Search for x and return pointer to node or nullptr (O(n))
    Node* search(int x) const {
        if (!tail) return nullptr;
        Node* cur = tail->next; // head
        for (size_t i = 0; i < sz; ++i) {
            if (cur->data == x) return cur;
            cur = cur->next;
        }
        return nullptr;
    }

    // Utility for demonstration
    void display() const {
        if (!tail) { cout << "List is empty\n"; return; }
        Node* cur = tail->next;
        cout << "List: ";
        for (size_t i = 0; i < sz; ++i) {
            cout << cur->data;
            if (i + 1 < sz) cout << " -> ";
            cur = cur->next;
        }
        cout << " (back to head)\n";
    }

    bool empty() const { return sz == 0; }
    size_t size() const { return sz; }
};

int main() {
    CircularLinkedList cll;
    int choice, x;

    while (true) {
        cout << "\nMenu:\n"
             << "1. Insert\n"
             << "2. Remove\n"
             << "3. Search\n"
             << "4. Display\n"
             << "0. Exit\n"
             << "Choose: ";
        if (!(cin >> choice)) {
            cout << "Invalid input. Exiting.\n";
            break;
        }

        switch (choice) {
            case 1:
                cout << "Enter value to insert: ";
                cin >> x;
                cll.insert(x);
                cout << "Inserted " << x << ".\n";
                break;

            case 2:
                cout << "Enter value to remove: ";
                cin >> x;
                if (cll.remove(x)) cout << "Removed " << x << ".\n";
                else cout << x << " not found.\n";
                break;

            case 3: {
                cout << "Enter value to search: ";
                cin >> x;
                auto p = cll.search(x);
                if (p) cout << "Found " << x << " at node address " << p << ".\n";
                else cout << x << " not found.\n";
                break;
            }

            case 4:
                cll.display();
                break;

            case 0:
                cout << "Exiting.\n";
                return 0;

            default:
                cout << "Invalid choice. Try again.\n";
        }
    }

    return 0;
}




























#include <iostream>
#include <string>
#include <cctype>
using namespace std;

// Node structure for the linked list implementation of the stack
struct Node {
    int data;
    Node* next;
    Node(int val) : data(val), next(nullptr) {}
};

// Stack ADT implementation using a linked list
class Stack {
private:
    Node* topNode;
public:
    Stack() : topNode(nullptr) {}
    
    void push(int value) {
        Node* newNode = new Node(value);
        newNode->next = topNode;
        topNode = newNode;
    }
    
    int pop() {
        if (isEmpty()) {
            throw runtime_error("Stack underflow!");
        }
        Node* temp = topNode;
        int poppedValue = topNode->data;
        topNode = topNode->next;
        delete temp;
        return poppedValue;
    }
    
    bool isEmpty() {
        return topNode == nullptr;
    }
    
    int top() {
        if (isEmpty()) {
            throw runtime_error("Stack is empty!");
        }
        return topNode->data;
    }
    
    ~Stack() {
        while (!isEmpty()) {
            pop();
        }
    }
};

// Function to check if a character is an operator
bool isOperator(char c) {
    return c == '+' || c == '-' || c == '*' || c == '/';
}

// Function to perform an operation
int applyOperator(char op, int a, int b) {
    switch(op) {
        case '+': return a + b;
        case '-': return a - b;
        case '*': return a * b;
        case '/': 
            if (b == 0) {
                throw runtime_error("Division by zero!");
            }
            return a / b;
        default:
            throw runtime_error("Invalid operator!");
    }
}

// Function to evaluate a postfix expression
int evaluatePostfix(const string& expr) {
    Stack stack;
    for (char c : expr) {
        if (isdigit(c)) {
            stack.push(c - '0');
        } else if (isOperator(c)) {
            int b = stack.pop();
            int a = stack.pop();
            stack.push(applyOperator(c, a, b));
        } else if (!isspace(c)) {
            throw runtime_error("Invalid character in expression!");
        }
    }
    if (stack.isEmpty()) {
        throw runtime_error("Invalid expression!");
    }
    int result = stack.pop();
    if (!stack.isEmpty()) {
        throw runtime_error("Invalid expression!");
    }
    return result;
}

// Function to evaluate a prefix expression
int evaluatePrefix(const string& expr) {
    Stack stack;
    for (int i = expr.size() - 1; i >= 0; i--) {
        char c = expr[i];
        if (isdigit(c)) {
            stack.push(c - '0');
        } else if (isOperator(c)) {
            int a = stack.pop();
            int b = stack.pop();
            stack.push(applyOperator(c, b, a));
        } else if (!isspace(c)) {
            throw runtime_error("Invalid character in expression!");
        }
    }
    if (stack.isEmpty()) {
        throw runtime_error("Invalid expression!");
    }
    int result = stack.pop();
    if (!stack.isEmpty()) {
        throw runtime_error("Invalid expression!");
    }
    return result;
}

// Interactive menu for expression evaluation
int main() {
    int choice;
    string expression;
    
    do {
        cout << "\n=== Expression Evaluation Menu ===" << endl;
        cout << "1. Evaluate Postfix Expression" << endl;
        cout << "2. Evaluate Prefix Expression" << endl;
        cout << "3. Exit" << endl;
        cout << "Enter your choice (1-3): ";
        cin >> choice;
        
        // Clear the input buffer
        cin.ignore();
        
        switch(choice) {
            case 1:
                cout << "Enter postfix expression (single digits, no spaces): ";
                getline(cin, expression);
                try {
                    cout << "Postfix Expression: " << expression << endl;
                    cout << "Result: " << evaluatePostfix(expression) << endl;
                } catch (const runtime_error& e) {
                    cout << "Error: " << e.what() << endl;
                }
                break;
                
            case 2:
                cout << "Enter prefix expression (single digits, no spaces): ";
                getline(cin, expression);
                try {
                    cout << "Prefix Expression: " << expression << endl;
                    cout << "Result: " << evaluatePrefix(expression) << endl;
                } catch (const runtime_error& e) {
                    cout << "Error: " << e.what() << endl;
                }
                break;
                
            case 3:
                cout << "Exiting program. Goodbye!" << endl;
                break;
                
            default:
                cout << "Invalid choice! Please try again." << endl;
        }
        
    } while (choice != 3);
    
    return 0;
}































#include <iostream>
#include <stdexcept> // Required for runtime_error
using namespace std;

class Node {
public:
    int data;
    Node* next;
    
    Node(int value) {
        data = value;
        next = nullptr;
    }
};

class Queue {
private:
    Node* front;
    Node* rear;
    int size;
    
public:
    Queue() {
        front = nullptr;
        rear = nullptr;
        size = 0;
    }
    
    void enqueue(int value) {
        Node* newNode = new Node(value);
        
        if (rear == nullptr) {
            front = rear = newNode;
        } else {
            rear->next = newNode;
            rear = newNode;
        }
        size++;
    }
    
    // Throws runtime_error if empty
    int dequeue() {
        if (isEmpty()) {
            throw runtime_error("Queue is empty (Underflow)!");
        }
        
        Node* temp = front;
        int dequeuedValue = front->data;
        front = front->next;
        
        if (front == nullptr) {
            rear = nullptr;
        }
        
        delete temp;
        size--;
        return dequeuedValue;
    }
    
    // Throws runtime_error if empty
    int getFront() {
        if (isEmpty()) {
            throw runtime_error("Queue is empty!");
        }
        return front->data;
    }
    
    // Throws runtime_error if empty
    int getRear() {
        if (isEmpty()) {
            throw runtime_error("Queue is empty!");
        }
        return rear->data;
    }
    
    bool isEmpty() {
        return front == nullptr;
    }
    
    int getSize() {
        return size;
    }
    
    void display() {
        if (isEmpty()) {
            cout << "Queue is empty" << endl;
            return;
        }
        
        Node* temp = front;
        while (temp != nullptr) {
            cout << temp->data << " ";
            temp = temp->next;
        }
        cout << endl;
    }
    
    ~Queue() {
        while (!isEmpty()) {
            dequeue(); 
        }
    }
};

// Interactive menu-driven program
int main() {
    Queue q;
    int choice, value;
    
    do {
        cout << "\n=== Queue Operations Menu ===" << endl;
        cout << "1. Enqueue (Add element)" << endl;
        cout << "2. Dequeue (Remove element)" << endl;
        cout << "3. Get Front element" << endl;
        cout << "4. Get Rear element" << endl;
        cout << "5. Check if empty" << endl;
        cout << "6. Get size" << endl;
        cout << "7. Display queue" << endl;
        cout << "8. Exit" << endl;
        cout << "Enter your choice (1-8): ";
        cin >> choice;
        
        switch(choice) {
            case 1:
                cout << "Enter value to enqueue: ";
                cin >> value;
                q.enqueue(value);
                cout << "Enqueued " << value << " successfully!" << endl;
                break;
                
            case 2:
                // !! DANGEROUS: If queue is empty, this line will crash the program !!
                value = q.dequeue();
                cout << "Dequeued element: " << value << endl;
                break;
                
            case 3:
                // !! DANGEROUS: If queue is empty, this line will crash the program !!
                value = q.getFront();
                cout << "Front element: " << value << endl;
                break;
                
            case 4:
                // !! DANGEROUS: If queue is empty, this line will crash the program !!
                value = q.getRear();
                cout << "Rear element: " << value << endl;
                break;
                
            case 5:
                if (q.isEmpty()) {
                    cout << "Queue is empty" << endl;
                } else {
                    cout << "Queue is not empty" << endl;
                }
                break;
                
            case 6:
                cout << "Current queue size: " << q.getSize() << endl;
                break;
                
            case 7:
                cout << "Queue elements: ";
                q.display();
                break;
                
            case 8:
                cout << "Exiting program. Goodbye!" << endl;
                break;
                
            default:
                cout << "Invalid choice! Please try again." << endl;
        }
        
    } while (choice != 8);
    
    return 0;
}





























#include <iostream>
using namespace std;

class BST {
    struct Node {
        int data;
        Node* left;
        Node* right;
        Node(int v): data(v), left(nullptr), right(nullptr) {}
    };
    Node* root = nullptr;

    Node* insert(Node* n, int v) {
        if (!n) return new Node(v);
        if (v < n->data) n->left = insert(n->left, v);
        else if (v > n->data) n->right = insert(n->right, v);
        return n;
    }

    Node* findMin(Node* n) {
        while (n->left) n = n->left;
        return n;
    }

    Node* remove(Node* n, int v) {
        if (!n) return nullptr;
        if (v < n->data) n->left = remove(n->left, v);
        else if (v > n->data) n->right = remove(n->right, v);
        else {
            if (!n->left) { Node* t = n->right; delete n; return t; }
            if (!n->right) { Node* t = n->left; delete n; return t; }
            Node* succ = findMin(n->right);
            n->data = succ->data;
            n->right = remove(n->right, succ->data);
        }
        return n;
    }

    bool search(Node* n, int v) {
        if (!n) return false;
        if (n->data == v) return true;
        return v < n->data ? search(n->left, v) : search(n->right, v);
    }

    void inorder(Node* n) {
        if (!n) return;
        inorder(n->left);
        cout << n->data << " ";
        inorder(n->right);
    }
    void preorder(Node* n) {
        if (!n) return;
        cout << n->data << " ";
        preorder(n->left);
        preorder(n->right);
    }
    void postorder(Node* n) {
        if (!n) return;
        postorder(n->left);
        postorder(n->right);
        cout << n->data << " ";
    }

public:
    void insert(int v) { root = insert(root, v); }
    void remove(int v) { root = remove(root, v); }
    bool search(int v) { return search(root, v); }

    void displayTraversals() {
        cout << "Inorder: "; inorder(root); cout << "\n";
        cout << "Preorder: "; preorder(root); cout << "\n";
        cout << "Postorder: "; postorder(root); cout << "\n";
    }
};

int main() {
    BST tree;
    int choice, value;
    do {
        cout << "\n1.Insert 2.Delete 3.Search 4.Display 5.Exit\nChoice: ";
        cin >> choice;
        switch (choice) {
            case 1: cin >> value; tree.insert(value); break;
            case 2: cin >> value; tree.remove(value); break;
            case 3: cin >> value; cout << (tree.search(value) ? "Found\n" : "Not found\n"); break;
            case 4: tree.displayTraversals(); break;
            case 5: break;
            default: cout << "Invalid choice\n";
        }
    } while (choice != 5);
    return 0;
}









































#include <iostream>
using namespace std;

class AVL {
    struct Node {
        int data;
        Node* left;
        Node* right;
        int height;
        Node(int v) : data(v), left(nullptr), right(nullptr), height(1) {}
    };
    
    Node* root = nullptr;

    int getHeight(Node* n) {
        return n ? n->height : 0;
    }

    int getBalance(Node* n) {
        return n ? getHeight(n->left) - getHeight(n->right) : 0;
    }

    Node* rightRotate(Node* y) {
        Node* x = y->left;
        Node* T2 = x->right;

        x->right = y;
        y->left = T2;

        y->height = max(getHeight(y->left), getHeight(y->right)) + 1;
        x->height = max(getHeight(x->left), getHeight(x->right)) + 1;

        return x;
    }

    Node* leftRotate(Node* x) {
        Node* y = x->right;
        Node* T2 = y->left;

        y->left = x;
        x->right = T2;

        x->height = max(getHeight(x->left), getHeight(x->right)) + 1;
        y->height = max(getHeight(y->left), getHeight(y->right)) + 1;

        return y;
    }

    Node* insert(Node* node, int value) {
        if (!node) return new Node(value);

        if (value < node->data)
            node->left = insert(node->left, value);
        else if (value > node->data)
            node->right = insert(node->right, value);
        else
            return node; // Duplicate values not allowed

        node->height = 1 + max(getHeight(node->left), getHeight(node->right));

        int balance = getBalance(node);

        // Left Left Case
        if (balance > 1 && value < node->left->data)
            return rightRotate(node);

        // Right Right Case
        if (balance < -1 && value > node->right->data)
            return leftRotate(node);

        // Left Right Case
        if (balance > 1 && value > node->left->data) {
            node->left = leftRotate(node->left);
            return rightRotate(node);
        }

        // Right Left Case
        if (balance < -1 && value < node->right->data) {
            node->right = rightRotate(node->right);
            return leftRotate(node);
        }

        return node;
    }

    bool search(Node* node, int value) {
        if (!node) return false;
        if (node->data == value) return true;
        return value < node->data ? search(node->left, value) : search(node->right, value);
    }

    void inorder(Node* node) {
        if (!node) return;
        inorder(node->left);
        cout << node->data << "(" << getBalance(node) << ") ";
        inorder(node->right);
    }

public:
    void insert(int value) {
        root = insert(root, value);
    }

    bool search(int value) {
        return search(root, value);
    }

    void display() {
        cout << "AVL Tree (value(balance)): ";
        inorder(root);
        cout << "\n";
    }
};

int main() {
    AVL tree;
    int choice, value;
    
    do {
        cout << "\n1. Insert\n2. Search\n3. Display\n4. Exit\nChoice: ";
        cin >> choice;
        
        switch(choice) {
            case 1:
                cout << "Enter value: ";
                cin >> value;
                tree.insert(value);
                break;
            case 2:
                cout << "Enter value: ";
                cin >> value;
                cout << (tree.search(value) ? "Found" : "Not found") << endl;
                break;
            case 3:
                tree.display();
                break;
            case 4:
                cout << "Exiting...\n";
                break;
            default:
                cout << "Invalid choice\n";
        }
    } while(choice != 4);
    
    return 0;
}
